<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://eztjy.ml/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>
</html>
<body>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://eztjy.ml"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-拉格朗日反演-FFT-NTT-多项式大全-详解" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/19/拉格朗日反演-FFT-NTT-多项式大全-详解/" class="article-date">
  <time datetime="2019-01-19T11:53:45.000Z" itemprop="datePublished">2019-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/19/拉格朗日反演-FFT-NTT-多项式大全-详解/">[拉格朗日反演][FFT][NTT][多项式大全]详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1、多项式的两种表示法"><a href="#1、多项式的两种表示法" class="headerlink" title="1、多项式的两种表示法"></a>1、多项式的两种表示法</h1><h2 id="1-系数表示法"><a href="#1-系数表示法" class="headerlink" title="1.系数表示法"></a>1.系数表示法</h2><p>我们最常用的多项式表示法就是系数表示法，一个次数界为$n$的多项式$S(x)$可以用一个向量$s=(s_0,s_1,s_2,\cdots,s_n-1)$<strong>系数表示</strong>如下：<script type="math/tex">S(x)=\sum_{k=0}^{n-1}s_kx^k</script></p>
<p>系数表示法很适合做加法，可以在$O(n)$的时间复杂度内完成，表达式为：<script type="math/tex">S(x)=A(x)+B(x)=\sum_{k=0}^{n-1}(a_k+b_k)x^k</script></p>
<p>当中<script type="math/tex">s_k=a_k+b_k</script></p>
<p>但是，系数表示法不适合做乘法，时间复杂度为$O(n^2)$，表达式为：<script type="math/tex">S(x)=A(x)B(x)=\sum_{k=0}^{n-1}\left(\sum_{j=0}^{n-1}a_j b_{k-j}\right)x^k</script></p>
<p>当中<script type="math/tex">s_k=\sum_{j=0}^k a_j b_{k-j}</script></p>
<p>这就是<strong>卷积</strong>的一般形式，记$s=a\otimes b$，我们要想办法加速这个过程。</p>
<h2 id="2-点值表示法"><a href="#2-点值表示法" class="headerlink" title="2.点值表示法"></a>2.点值表示法</h2><p>顾名思义，点值就是多项式在一个点处的值。多项式$A(x)$的<strong>点值表达</strong>是一个集合：<script type="math/tex">\{(x_0,y_0),(x_1,y_1),(x_2,y_2),\cdots,(x_{n-1},y_{n-1})\}</script></p>
<p>使得对于$k=0,1,2,\cdots,n-1$有$x_k$两两不相同且$y_k=A(x_k)$。</p>
<p>$n$个点可以确定唯一一个$n$次多项式。</p>
<p>点值表达有很多优良的性质，加法和乘法都可以在$O(n)$的时间复杂度内完成。</p>
<p>现有$A(x)$的点值表达<script type="math/tex">\{(x_0,y_0),(x_1,y_1),(x_2,y_2),\cdots,(x_{n-1},y_{n-1})\}</script>和$B(x)$的点值表达<script type="math/tex">\{(x_0,y'_0),(x_1,y'_1),(x_2,y'_2),\cdots,(x_{n-1},y'_{n-1})\}</script></p>
<p>则$C(x)=A(x)+B(x)$的点值表达为：<script type="math/tex">\{(x_0,y_0+y'_0),(x_1,y_1+y'_1),(x_2,y_2+y'_2),\cdots,(x_{n-1},y_{n-1}+y'_{n-1})\}</script></p>
<p>$C(x)=A(x)B(x)$的点值表达为：<script type="math/tex">\{(x_0,y_0 y'_0),(x_1,y_1 y'_1),(x_2,y_2 y'_2),\cdots,(x_{n-1},y_{n-1} y'_{n-1})\}</script></p>
<p>可见，点值表示可以帮助我们更快地进行卷积，可是如何在系数表示法和点值表示法之间相互转化呢？</p>
<h1 id="2、复数"><a href="#2、复数" class="headerlink" title="2、复数"></a>2、复数</h1><p>当$x$为实数时，无法很好地对转换方法进行优化。为了优化计算$x^n$所浪费的时间，我们需要$x$有循环的性质。但点值表示法需要$n$个两两不同的值，而在实数域中只有$1$和$-1$，因此，我们需要复数的帮助。</p>
<h2 id="1-复数、复平面的定义"><a href="#1-复数、复平面的定义" class="headerlink" title="1.复数、复平面的定义"></a>1.复数、复平面的定义</h2><p>我们把形如$a+bi$的数称为<strong>复数</strong>$z$，其中$a$为<strong>实部(Real)</strong>，记为$\Re z$；$b$为<strong>虚部(Imaginary)</strong>，记为$\Im z$。</p>
<p>每一点都对应唯一复数的平面叫<strong>复平面</strong>，相当于一个把$\Re z$作为横坐标，把$\Im z$作为纵坐标的笛卡尔坐标系。如图：<br><img src="https://img-blog.csdn.net/20180505211152335?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VaX1RKWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p><strong>模长</strong>：复平面上原点到复数$z$的距离，记为$|z|$。根据勾股定理，$|z|=|a+bi|=\sqrt{a^2+b^2}$</p>
<p><strong>辐角</strong>：复平面上$x$轴与复数$z$所对应向量之间的夹角，在$(-\frac{\pi}{2},\frac{\pi}{2})$之间的记为<strong>辐角主值</strong>$\arg z$。</p>
<h2 id="2-欧拉公式"><a href="#2-欧拉公式" class="headerlink" title="2.欧拉公式"></a>2.欧拉公式</h2><p>大名鼎鼎的欧拉公式：<script type="math/tex">e^{i t}=\cos t+i\sin t</script></p>
<p>根据三角函数在单位圆上的几何意义，公式是容易理解的。</p>
<p>几何意义：<br><img src="https://img-blog.csdn.net/20180506122458230?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VaX1RKWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>当中$\theta$为角度，$t$为弧长。</p>
<p><strong>证明</strong>：</p>
<p>对$\exp(x)$在$x=0$泰勒展开：<script type="math/tex">\exp(x)=\sum_{k=0}^\infty\frac{x^k}{k!}</script></p>
<p>对$\sin(x)$在$x=0$泰勒展开：<script type="math/tex">\sin(x)=\sum_{k=0}^\infty\frac{x^{4 k+1}}{(4 k+1)!}-\sum_{k=0}^\infty\frac{x^{4 k+3}}{(4 k+3)!}</script></p>
<p>对$\cos(x)$在$x=0$泰勒展开：<script type="math/tex">\cos(x)=\sum_{k=0}^\infty\frac{x^{4 k}}{(4 k)!}-\sum_{k=0}^\infty\frac{x^{4 k+2}}{(4 k+2)!}</script></p>
<p>把$\exp(x)$中的$x$替换为$i x$：<script type="math/tex">\exp(i x)=\sum_{k=0}^\infty\frac{x^{4 k}}{(4 k)!}+i\sum_{k=0}^\infty\frac{x^{4 k+1}}{(4 k+1)!}-\sum_{k=0}^\infty\frac{x^{4 k+2}}{(4 k+2)!}-i\sum_{k=0}^\infty\frac{x^{4 k+3}}{(4 k+3)!}</script></p>
<p>则显然有：<script type="math/tex">e^{i x}=\cos x+i\sin x</script></p>
<p>证毕。</p>
<p>则根据欧拉公式，可将一个复数表示为一个二元组$(a,\theta)$，即模长和辐角（相当于复平面上极坐标系的表示方法）。值为:$a(\cos\theta+i\sin\theta)$</p>
<p>特殊情况：欧拉恒等式$e^{i\pi}+1=0$</p>
<h2 id="3-复数的运算"><a href="#3-复数的运算" class="headerlink" title="3.复数的运算"></a>3.复数的运算</h2><h3 id="（1）复数加法"><a href="#（1）复数加法" class="headerlink" title="（1）复数加法"></a>（1）复数加法</h3><p>运算规则：<strong>实部、虚部分别相加</strong><script type="math/tex">(a+bi)+(c+di)=a+c+bi+di=(a+c)+(b+d)i</script></p>
<p>几何意义：如图<br><img src="https://img-blog.csdn.net/20180505212817759?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VaX1RKWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""></p>
<p>结果相当于<strong>两个向量所构成的平行四边形的对角线</strong>。如果把一个复数所对应的向量视为一个移动的变换，那么向量加法就是连续运用这两个变换相当于的新变换。</p>
<h3 id="（2）复数乘法"><a href="#（2）复数乘法" class="headerlink" title="（2）复数乘法"></a>（2）复数乘法</h3><p>运算规则：<strong>展开</strong><script type="math/tex">(a+bi)(c+di)=ac+adi+bci+bdi^2=(ac-bd)+(ad+bc)i</script></p>
<p>几何意义：如图<br><img src="https://img-blog.csdn.net/20180506105100660?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VaX1RKWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>如图，$\arg a+\arg b=\arg a\times b$,$|a|\times|b|=|a\times b|$</p>
<p>总结就是：<strong>模长相乘，辐角相加</strong>。</p>
<p>因此，如果模长为$1$，那么它的$n$次方一定还在<strong>单位圆</strong>上。</p>
<p><strong>证明：</strong></p>
<p>根据欧拉公式，已知$x=(a_1,\theta_1)=a_1(\cos\theta_1+i\sin\theta_1),y=(a_2,\theta_2)=a_2(\cos\theta_2+i\sin\theta_2)$</p>
<p>则<script type="math/tex">\begin{align*}
x\times y&=a_1 a_2(\cos\theta_1+i\sin\theta_1)(\cos\theta_2+i\sin\theta_2)\\
&=a_1 a_2\left[(\cos\theta_1\cos\theta_2-\sin\theta_1\sin\theta_2)+i(\cos\theta_1\sin\theta_2+\sin\theta_1\cos\theta_2)\right]\\
&=a_1 a_2\left[\left(\frac{\cos(\theta_1+\theta_2)+\cos(\theta_1-\theta_2)}{2}+\frac{\cos(\theta_1+\theta_2)-\cos(\theta_1-\theta_2)}{2}\right)\right.\\
&\left.+i\left(\frac{\sin(\theta_1+\theta_2)-\sin(\theta_1-\theta_2)}{2}+\frac{\sin(\theta_1+\theta_2)+\sin(\theta_1-\theta_2)}{2}\right)\right]\tag{积化和差公式}\\
&=a_1 a_2\left[\cos(\theta_1+\theta_2)+i\sin(\theta_1+\theta_2)\right]
\end{align*}</script></p>
<p>$\therefore |x\times y|=|x|\times |y|,\arg(x\times y)=\arg x+\arg y$</p>
<p>证毕。</p>
<h2 id="4-单位复数根"><a href="#4-单位复数根" class="headerlink" title="4.单位复数根"></a>4.单位复数根</h2><h3 id="（1）基本性质"><a href="#（1）基本性质" class="headerlink" title="（1）基本性质"></a>（1）基本性质</h3><p><strong>单位复数根</strong>是方程$\omega^n=1$的解，第$k$个解记为$\omega_n^k$(这里的$k$事实上是乘方的含义)</p>
<p>$n=16$的解在复平面上的位置如下：<br><img src="https://img-blog.csdn.net/20180506113941633?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VaX1RKWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>可以看到，$n$个解把单位圆分成了$n$等弧，交点即为根。而且，$\omega_n^k$实际上是$\omega_n$的$n$次方，模长仍为$1$,辐角翻倍！</p>
<p>为什么呢？</p>
<p>$\because |x^n|=|x|^n,\arg x^n=n\arg x$</p>
<p>$\therefore |\omega|^n=|\omega^n|,\arg\omega^n=n\arg\omega$</p>
<p>$\therefore |\omega|^n=1(|\omega|\in\mathbb{R}^+),\arg\omega=\frac{360^\circ}{n}$</p>
<p>$\therefore |\omega|=1,\arg\omega=\frac{360^\circ}{n}$</p>
<p>这就很明显了。</p>
<p>所以，$\omega_n^k$事实上表示的是$\omega_n$的$k$次幂。为什么选择单位复数根呢？因为它有循环的优良性质，即$\omega_n^n=1$。由于其他的都可以由$\omega_n^1$得到，因此称为主$n$次单位根，又记为$\omega_n$。</p>
<p>根据单位复数根的平分圆的意义和欧拉公式，$\omega_n^k=e^\frac{2\pi i k}{n}=\cos\frac{2\pi k}{n}+i\sin\frac{2\pi k}{n}$。</p>
<h3 id="（2）计算引理"><a href="#（2）计算引理" class="headerlink" title="（2）计算引理"></a>（2）计算引理</h3><p>显然，由于单位复数根循环($\omega_n^{zn}=e^{2\pi iz}=\left[\left(e^{\pi i}\right)^2\right]^z=1^z=1$)，有<strong>变换恒等式</strong>：<script type="math/tex">\omega_n^k=\omega_n^{k+wn}(w\in\mathbb{Z})</script></p>
<p>每一份再分成$k$份，编号也变成$k$倍，位置自然不变($\omega_{d n}^{d k}=e^\frac{2\pi i d k}{dn}=e^\frac{2\pi i k}{n}=\omega_n^k$)，所以有<strong>消去引理</strong>：<script type="math/tex">\omega_{d n}^{d k}=\omega_n^k</script></p>
<p>由于过了$n/2$就会绕过半圈($\omega_n^{n/2}=e^\frac{\pi i n}{n}=e^{\pi i}=-1$)，所以有<strong>折半引理</strong>：<script type="math/tex">\omega_n^k=-\omega_n^{k\pm n/2}</script></p>
<p>对单位复数根求和，根据几何级数(等差数列求和公式)，可得($\sum\limits_{k=0}^{n-1}(\omega_n^k)^j=\frac{(\omega_n^n)^j-1}{\omega_n^1-1}=0$)，即有<strong>求和引理</strong>（要注意公式的使用条件）：<script type="math/tex">\sum_{k=0}^{n-1}(\omega_n^k)^j=0,\omega_n\ne 1</script></p>
<h1 id="3、DFT-amp-FFT"><a href="#3、DFT-amp-FFT" class="headerlink" title="3、DFT&amp;FFT"></a>3、DFT&amp;FFT</h1><h2 id="1-DFT"><a href="#1-DFT" class="headerlink" title="1.DFT"></a>1.DFT</h2><p>DFT就是求多项式$A(x)$在点$(\omega_n^0,\omega_n^1,\omega_n^2,\cdots,\omega_n^{n-1})$处取值的过程。即：<script type="math/tex">y_k=A(\omega_n^k)=\sum_{j=0}^{n-1}a_j\omega_n^{kj}</script></p>
<p>结果$y=(y_0,y_1,y_2,\cdots,y_{n-1})$就是$a$的<strong>离散傅里叶变换(DFT)</strong>,记为$y=DFT_n(a)$</p>
<h2 id="2-FFT"><a href="#2-FFT" class="headerlink" title="2.FFT"></a>2.FFT</h2><h3 id="（1）递归"><a href="#（1）递归" class="headerlink" title="（1）递归"></a>（1）递归</h3><p>DFT的$O(n^2)$算法太慢了，FFT使用分治策略优化速度到$O(n\log n)$。</p>
<p>考虑奇偶分治。</p>
<p>现在，我们假设$n=2^t$，设原系数$a=(a_0,a_1,a_2,\cdots,a_{n-1})$，分治为偶数部分$a_1=(a_0,a_2,a_4,\cdots,a_{n-2})$，奇数部分$a_2=(a_1,a_3,a_5,\cdots,a_{n-1})$，已经递归求出$y_1=DFT_{n/2}(a_1)$，$y_2=DFT_{n/2}(a_2)$，现在我们要合并$y_1,y_2$，得到$y=DFT_n(a)$(<strong>蝴蝶操作</strong>)。</p>
<p>对于$n=1$的边界情况，结果是显然的：因为$k=0$，故$\omega_1^0=1$，即结果等于原系数。</p>
<p>对于$n&gt;1$，现在我们枚举$k\in[1,n]$要合并出$y_k$：</p>
<script type="math/tex; mode=display">\begin{align*}
y_k&=A(\omega_n^k)\\
&=\sum_{j=0}^{n-1}a_j\omega_n^{kj}\\
&=\sum_{j=0}^{n/2-1}a_{2 j}\omega_n^{2 k j}+\sum_{j=0}^{n/2-1}a_{2 j+1}\omega_n^{2 k j+k}\\
&=\sum_{j=0}^{n/2-1}a_{2 j}\omega_n^{2 k j}+\omega_n^k\sum_{j=0}^{n/2-1}a_{2 j+1}\omega_n^{2 k j}\\
&=\sum_{j=0}^{n/2-1}a_{1_j}\omega_{n/2}^{k j}+\omega_n^k\sum_{j=0}^{n/2-1}a_{2_j}\omega_{n/2}^{k j}\tag{消去引理}
\end{align*}</script><ul>
<li><p>对于$k&lt;n/2$：</p>
<script type="math/tex; mode=display">\begin{align*}
y_k&=y_{1_k}+\omega_n^k y_{2_k}
\end{align*}</script></li>
<li><p>对于$k\geq n/2$：</p>
<script type="math/tex; mode=display">\begin{align*}
y_k&=\sum_{j=0}^{n/2-1}a_{1_j}\omega_{n/2}^{(k-n/2)j}+\omega_n^k\sum_{j=0}^{n/2-1}a_{2_j}\omega_{n/2}^{(k-n/2)j}\tag{变换恒等式}\\
&=y_{1_{k-n/2}}+\omega_n^k y_{2_{k-n/2}}\\
&=y_{1_{k-n/2}}-\omega_n^{k-n/2}y_{2_{k-n/2}}\tag{折半引理}
\end{align*}</script></li>
</ul>
<p>我们用$k+n/2$替代$k$，就得到$y_{k+n/2}=y_{1_k}-\omega_n^k y_{2_k}$</p>
<p>结合在一起就得到$\begin{cases}y_k&amp;=y_{1_k}+\omega_n^k y_{2_k}\\y_{k+n/2}&amp;=y_{1_k}-\omega_n^k y_{2_k}\end{cases}$<br>这样我们就可以把两个$n/2$长的序列合并为一个$n$长的序列了。</p>
<p>以下图的递归序，就可以在$O(n\log n)$的时间复杂度内完成求解了。<br><img src="http://img.blog.csdn.net/20170901201507165?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZXpfeXd3/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt=""></p>
<h3 id="（2）迭代"><a href="#（2）迭代" class="headerlink" title="（2）迭代"></a>（2）迭代</h3><p>递归方法消耗内存、时间过大，无法承受。我们每次把下标分为奇数部分和偶数部分，是否有办法直接求出最后的递归运算顺序，以避免递归呢？</p>
<p>这样想：<br>第一次奇偶划分，我们<strong>按照二进制的倒数第一位排序</strong>；<br>第二次奇偶划分，我们<strong>按照二进制的倒数第二位排序</strong>；<br>第$n$次奇偶划分，我们<strong>按照二进制的倒数第$n$位排序</strong>；<br>依此类推。</p>
<p>因此，结果顺序就是原序列按照<strong>二进制位翻转</strong>的大小排序的结果。只要依次交换$a_k,a_{rev(k)}$，求出序列，就可以用迭代方法相邻归并实现快速傅里叶变换。</p>
<p>或者，我们也可以用更加代数的方法来发现这个结论。<br>已知现在位置为$k=(b_1 b_2 b_3 \cdots b_n)_2$，按照奇偶重排：</p>
<ul>
<li>若$b_n=0$，则位置变为$\frac{k}{2}=(0 b_1 b_2 \cdots b_{n-1})_2=(b_n b_1 b_2 \cdots b_{n-1})_2$，即为把最后一位提到第一位。</li>
<li>若$b_n=1$，则位置变为$2^{n-1}-1+\frac{k+1}{2}=\frac{2^n+k-1}{2}=\frac{(1 b_1 b_2 \cdots b_{n-1} 0)_2}{2}=(b_n b_1 b_2 \cdots b_{n-1})_2$，同样是把最后一位提到第一位。</li>
</ul>
<p>则反复$n$次之后，就相当于二进制反转了。</p>
<p>如$n=8$时，求出二进制：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$000_2$</td>
<td style="text-align:center">$001_2$</td>
<td style="text-align:center">$010_2$</td>
<td style="text-align:center">$011_2$</td>
<td style="text-align:center">$100_2$</td>
<td style="text-align:center">$101_2$</td>
<td style="text-align:center">$110_2$</td>
<td style="text-align:center">$111_2$</td>
</tr>
</tbody>
</table>
</div>
<p>翻转：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$000_2$</td>
<td style="text-align:center">$100_2$</td>
<td style="text-align:center">$010_2$</td>
<td style="text-align:center">$110_2$</td>
<td style="text-align:center">$001_2$</td>
<td style="text-align:center">$101_2$</td>
<td style="text-align:center">$011_2$</td>
<td style="text-align:center">$111_2$</td>
</tr>
</tbody>
</table>
</div>
<p>按翻转后的值排序：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">0</th>
<th style="text-align:center">4</th>
<th style="text-align:center">2</th>
<th style="text-align:center">6</th>
<th style="text-align:center">1</th>
<th style="text-align:center">5</th>
<th style="text-align:center">3</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$000_2$</td>
<td style="text-align:center">$001_2$</td>
<td style="text-align:center">$010_2$</td>
<td style="text-align:center">$011_2$</td>
<td style="text-align:center">$100_2$</td>
<td style="text-align:center">$101_2$</td>
<td style="text-align:center">$110_2$</td>
<td style="text-align:center">$111_2$</td>
</tr>
</tbody>
</table>
</div>
<p>这样就可以把奇偶合并转化为左右归并，迭代实现了。</p>
<h1 id="5、IDFT-amp-IFFT"><a href="#5、IDFT-amp-IFFT" class="headerlink" title="5、IDFT&amp;IFFT"></a>5、IDFT&amp;IFFT</h1><p>何把点值表达变回系数表达呢？如果把求值写成矩阵形式，就是：</p>
<script type="math/tex; mode=display">\begin{bmatrix}
\omega_n^0 & \omega_n^0 & \omega_n^0 & \omega_n^0 & \cdots & \omega_n^0 \\
\omega_n^0 & \omega_n^1 & \omega_n^2 & \omega_n^3 & \cdots & \omega_n^{n-1} \\
\omega_n^0 & \omega_n^2 & \omega_n^4 & \omega_n^6 & \cdots & \omega_n^{2(n-1)} \\
\omega_n^0 & \omega_n^3 & \omega_n^6 & \omega_n^9 & \cdots & \omega_n^{3(n-1)} \\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
\omega_n^0 & \omega_n^{n-1} & \omega_n^{2(n-1)} & \omega_n^{3(n-1)} & \cdots & \omega_n^{(n-1)^2}
\end{bmatrix}
\begin{bmatrix}
a_0 \\ a_1 \\ a_2 \\ a_3 \\ \vdots \\ a_{n-1}
\end{bmatrix}=
\begin{bmatrix}
y_0 \\ y_1 \\ y_2 \\ y_3 \\ \vdots \\ y_{n-1}
\end{bmatrix}</script><p>如果我们要把$y$变成$a$，就需要求出第一个矩阵的逆，即：</p>
<script type="math/tex; mode=display">\begin{bmatrix}
a_0 \\ a_1 \\ a_2 \\ a_3 \\ \vdots \\ a_{n-1}
\end{bmatrix}=
\begin{bmatrix}
\omega_n^0 & \omega_n^0 & \omega_n^0 & \omega_n^0 & \cdots & \omega_n^0 \\
\omega_n^0 & \omega_n^1 & \omega_n^2 & \omega_n^3 & \cdots & \omega_n^{n-1} \\
\omega_n^0 & \omega_n^2 & \omega_n^4 & \omega_n^6 & \cdots & \omega_n^{2(n-1)} \\
\omega_n^0 & \omega_n^3 & \omega_n^6 & \omega_n^9 & \cdots & \omega_n^{3(n-1)} \\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
\omega_n^0 & \omega_n^{n-1} & \omega_n^{2(n-1)} & \omega_n^{3(n-1)} & \cdots & \omega_n^{(n-1)^2}
\end{bmatrix}^{-1}
\begin{bmatrix}
y_0 \\ y_1 \\ y_2 \\ y_3 \\ \vdots \\ y_{n-1}
\end{bmatrix}</script><p>这个<strong>范德蒙德矩阵</strong>极为特殊，它的逆矩阵是：</p>
<script type="math/tex; mode=display">\begin{bmatrix}
a_0 \\ a_1 \\ a_2 \\ a_3 \\ \vdots \\ a_{n-1}
\end{bmatrix}=\frac{1}{n}
\begin{bmatrix}
\omega_n^0 & \omega_n^0 & \omega_n^0 & \omega_n^0 & \cdots & \omega_n^0 \\
\omega_n^0 & \omega_n^{-1} & \omega_n^{-2} & \omega_n^{-3} & \cdots & \omega_n^{-(n-1)} \\
\omega_n^0 & \omega_n^{-2} & \omega_n^{-4} & \omega_n^{-6} & \cdots & \omega_n^{-2(n-1)} \\
\omega_n^0 & \omega_n^{-3} & \omega_n^{-6} & \omega_n^{-9} & \cdots & \omega_n^{-3(n-1)} \\
\vdots & \vdots & \vdots & \vdots & \ddots & \vdots \\
\omega_n^0 & \omega_n^{-(n-1)} & \omega_n^{-2(n-1)} & \omega_n^{-3(n-1)} & \cdots & \omega_n^{-(n-1)^2}
\end{bmatrix}
\begin{bmatrix}
y_0 \\ y_1 \\ y_2 \\ y_3 \\ \vdots \\ y_{n-1}
\end{bmatrix}</script><p>只是把每项取倒数，并将结果除以$n$即可。</p>
<p><strong>证明</strong>：</p>
<p>记原矩阵为$A_{n n}$,我们给出的矩阵为$B_{n n}$。</p>
<p>$\therefore A_{i j}=\omega_n^{i j},B_{i j}=\frac{1}{n}\omega_n^{-i j}(0\le i,j\le n-1)$</p>
<script type="math/tex; mode=display">\begin{align*}
AB_{i j}&=\sum_{k=0}^{n-1} A_{i k}B_{k j}\\
&=\frac{1}{n}\sum_{k=0}^{n-1} \omega_n^{i k}\omega_n^{-k j}\\
&=\frac{1}{n}\sum_{k=0}^{n-1} \omega_n^{i k-k j}\\
&=\frac{1}{n}\sum_{k=0}^{n-1} (\omega_n^{i-j})^k
\end{align*}</script><ul>
<li>当$i=j$时：</li>
</ul>
<script type="math/tex; mode=display">\begin{align*}
AB_{i j}&=\frac{1}{n}\sum_{k=0}^{n-1}1^k\\
&=\frac{1}{n}\times n\\
&=1
\end{align*}</script><ul>
<li>当$i\ne j$时：</li>
</ul>
<script type="math/tex; mode=display">\begin{align*}
AB_{i j}&=\frac{1}{n}\sum_{k=0}^{n-1}(\omega_n^{i-j})^k\\
&=0\tag{求和引理}
\end{align*}</script><p>综上所述，$AB=I_n$，即$B=A^{-1}$</p>
<p>以上，<strong>离散傅里叶逆变换(IDFT)</strong>的表达式为：<script type="math/tex">a_k=\frac{1}{n}\sum_{j=0}^{n-1}y_k\omega_n^{-k j}</script><br>记$a=IDFT_n(y)$。</p>
<p>同理，可以用相同的方法把IDFT加速到$O(n\log n)$,称为IFFT。</p>
<h1 id="5、NTT"><a href="#5、NTT" class="headerlink" title="5、NTT"></a>5、NTT</h1><h2 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h2><p>有时候我们会想要模素数$p$意义下的多项式乘法。此时，由次数界为$n$的多项式$A(x),B(x)$的系数表达$a,b$求$S(x)=A(x)B(x)$的系数表达$s$的公式为：<script type="math/tex">s_k=\sum_{j=0}^k a_j b_{k-j}\mod p</script></p>
<p>FFT无能为力，我们需要一种新的DFT，以数论的办法进行，这就是<strong>快速数论变换(NTT)</strong>。</p>
<h2 id="2-原根"><a href="#2-原根" class="headerlink" title="2.原根"></a>2.原根</h2><h3 id="（1）定义"><a href="#（1）定义" class="headerlink" title="（1）定义"></a>（1）定义</h3><p>我们需要一种有数论循环性质的新数，<strong>原根</strong>恰好满足我们的要求。</p>
<p>设$m$为正整数，$a$为整数，若$a$模$m$的阶等于$\varphi(m)$，则称$a$为模$m$的一个原根。</p>
<p>假设$g$是素数$p$的原根，有$1&lt;g&lt;p$，且对于$k=0,1,2,\cdots,p-1$，有$g^k\mod p$的结果<strong>两两不同</strong>，且$g^{p-1}\equiv 1 \pmod p$。</p>
<p>可以发现，原根同样有循环的性质。因此，我们类比$\omega_n^k$的定义，把原来的$\omega_n^k=e^\frac{2\pi ik}{n}$替换为$g^\frac{k(p-1)}{n}$。</p>
<h3 id="（2）性质"><a href="#（2）性质" class="headerlink" title="（2）性质"></a>（2）性质</h3><p>我们来证明一些类似单位复数根的性质。</p>
<p><strong>变换恒等式</strong>：<br>因为：<script type="math/tex">g^{p-1}\equiv 1</script></p>
<p>所以：<script type="math/tex">g^\frac{(k+n)(p-1)}{n}\equiv g^\frac{k(p-1)}{n}g^{p-1}\equiv g^\frac{k(p-1)}{n}</script></p>
<hr>
<p><strong>消去引理</strong>：<br>显然有：<script type="math/tex">g^\frac{d k(p-1)}{d n}\equiv g^\frac{k(p-1)}{n}</script></p>
<hr>
<p><strong>折半引理</strong>：<br>因为：<script type="math/tex">g^\frac{(k+\frac{n}{2})(p-1)}{n}\equiv g^\frac{k(p-1)}{n}g^\frac{p-1}{2}</script></p>
<p>所以若要使：<script type="math/tex">g^\frac{k(p-1)}{n}+g^\frac{(k+\frac{n}{2})(p-1)}{n}\equiv 0\pmod p</script></p>
<p>成立，即：<script type="math/tex">g^\frac{k(p-1)}{2}\left(1+g^\frac{p-1}{2}\right)\equiv 0</script></p>
<p>只需证：<script type="math/tex">g^\frac{p-1}{2}\equiv p-1</script></p>
<p>由于：<script type="math/tex">g^{k}\equiv 0,1,2,\cdots,p-1</script></p>
<p>那么我们可以设：<script type="math/tex">g^\frac{p-1}{2}\equiv x,x=0,1,2,\cdots,p-1</script></p>
<p>因为：<script type="math/tex">\left(g^\frac{p-1}{2}\right)^2\equiv g^{p-1}\equiv 1</script></p>
<p>所以：<script type="math/tex">x^2-1\equiv 0</script></p>
<p>即：<script type="math/tex">(x+1)(x-1)\equiv 0</script></p>
<p>又因为$p$为素数，所以有：<script type="math/tex">x+1\equiv 0\;或\;x-1\equiv 0</script></p>
<p>所以：<script type="math/tex">x=1,p-1</script></p>
<p>又因为：<script type="math/tex">g^{p-1}\equiv 1,g^k\mod p两两不同</script></p>
<p>所以：<script type="math/tex">x=p-1</script></p>
<p>即：<script type="math/tex">g^\frac{p-1}{2}\equiv p-1</script></p>
<p>得证：<script type="math/tex">g^\frac{k(p-1)}{n}+g^\frac{(k+\frac{n}{2})(p-1)}{n}\equiv 0</script></p>
<hr>
<p><strong>求和引理</strong>：</p>
<script type="math/tex; mode=display">\sum\limits_{k=0}^{n-1}g^\frac{k j(p-1)}{n}\equiv\sum\limits_{k=0}^{n-1}\left(g^\frac{j(p-1)}{n}\right)^k\equiv\frac{g^\frac{n j(p-1)}{n}-1}{g^\frac{j(p-1)}{n}-1}\equiv\frac{\left(g^{p-1}\right)^j-1}{g^\frac{j(p-1)}{n}-1}\equiv 0</script><p>这样，我们就证明了原根由于复数单位根相同的性质。</p>
<h2 id="3-公式"><a href="#3-公式" class="headerlink" title="3.公式"></a>3.公式</h2><p>我们用原根替换复数单位根，得到：<script type="math/tex">y_k=A(g^\frac{k(p-1)}{n})=\sum_{j=0}^{n-1}a_k g^\frac{k j(p-1)}{n}</script></p>
<p>即$y=NTT_n(a)$。逆变换：<script type="math/tex">a_k=\frac{1}{n}\sum_{j=0}^{n-1}y_k g^\frac{-k j(p-1)}{n}</script></p>
<p>即$a=INTT_n(y)$。</p>
<h1 id="6、其他扩展"><a href="#6、其他扩展" class="headerlink" title="6、其他扩展"></a>6、其他扩展</h1><h2 id="1-任意模数FFT"><a href="#1-任意模数FFT" class="headerlink" title="1.任意模数FFT"></a>1.任意模数FFT</h2><p>有的时候我们需要卷积后模上一个数，这个数不是NTT模数，甚至可能不是个质数。那我们该怎么做呢？</p>
<p>这里使用拆系数FFT，本质是以时间换精度。</p>
<p>现在给定次数界为$m$的两个多项式$A(x),B(x)$，要求$A(x)B(x) \mod P$。</p>
<p>首先，令$M=\lfloor\sqrt{P}\rfloor$，再对于每个$a_i$或$b_i$，把其变为$k_i M+r_i(r_i&lt;M)$的形式。这样，$k_i$和$r_i$就都小于等于$M$了。</p>
<p>那么卷积就可以写成：<script type="math/tex">c_i=\sum_{k=0}^i a_k b_{i-k}=\sum_{k=0}^i(k_{a_i}M+r_{a_i})(k_{b_{i-k}}M+r_{b_{i-k}})=M^2\sum_{k=0}^i k_{a_i}k_{b_{i-k}}+M\sum_{k=0}^i (k_{a_i}r_{b_{i-k}}+r_{a_i}k_{b_{i-k}})+\sum_{k=0}^i r_{a_i}r_{b_{i-k}}</script></p>
<p>那么我们看到，$c_i$可以由$k$和$r$合并得到。那么我们对$k_a,k_b,r_a,r_b$分别做FFT，再对应算出$x_1=k_a k_b,x_2=k_a r_b+r_a k_b,x_3=r_a r_b$，对它们再分别做IFFT，就可以由$c=M^2 x_1+M x_2+x_3$得到答案了。</p>
<p>这么做的好处究竟在哪里呢？事实上，计算后的最大值由$m P$变为了$m \lfloor\sqrt{P}\rfloor$，避免了溢出。</p>
<p>时间复杂度：$O(n\log n)$，常数为$7$。</p>
<h2 id="2-多项式求逆"><a href="#2-多项式求逆" class="headerlink" title="2.多项式求逆"></a>2.多项式求逆</h2><p>现在我们有一个次数界为$n$的多项式$A(x)$，要求$B(x)$满足$A(x)B(x)\equiv 1\pmod{x^n}$。</p>
<p>我们考虑倍增实现。</p>
<ul>
<li>当$n=1$时，直接求逆元求得$B(x)\equiv A(x)^{p-2}$。</li>
<li>当$n&gt;1$时，已有$A(x)G(x)\equiv 1\pmod{x^\frac{n}{2}}$：</li>
</ul>
<p>因为：<script type="math/tex">A(x)B(x)\equiv 1\pmod{x^n}</script></p>
<p>又因为除了$0$次项之外到$n-1$次都为$0$，因此到$\frac{n}{2}-1$次项也为零：<script type="math/tex">A(x)B(x)\equiv 1\pmod{x^\frac{n}{2}}</script></p>
<p>又<script type="math/tex">A(x)G(x)\equiv 1\pmod{x^\frac{n}{2}}</script></p>
<p>两式相减：<script type="math/tex">A(x)[B(x)-G(x)]\equiv 0\pmod{x^\frac{n}{2}}</script></p>
<p>因为：<script type="math/tex">A(x)\ne 0</script></p>
<p>所以：<script type="math/tex">B(x)-G(x)\equiv 0\pmod{x^\frac{n}{2}}</script></p>
<p>既然$0$至$\frac{n}{2}-1$次项都为零，那么平方之后$0$至$n-1$次项也为零：<script type="math/tex">B(x)^2-2 B(x)G(x)+G(x)^2\equiv 0\pmod{x^n}</script></p>
<p>又<script type="math/tex">A(x)B(x)\equiv 1\pmod{x^n}</script></p>
<p>两边同时乘上$A(x)$，得：<script type="math/tex">B(x)-2 G(x)+A(x)G(x)^2\equiv 0\pmod{x^n}</script></p>
<p>移项，得：<script type="math/tex">B(x)\equiv 2 G(x)-A(x)G(x)^2\pmod{x^n}</script></p>
<p>这样就可以了。</p>
<p><strong>时间复杂度证明</strong>：</p>
<p>显然有递归式：</p>
<script type="math/tex; mode=display">\begin{cases}T(0)=1\\T(n)=T(\frac{n}{2})+n\log_2(n)\end{cases}</script><p>展开可得：<script type="math/tex">\begin{align*}
T(n)&=\sum_{i=0}^{\log_2(n)}2^i \log_2(2^i)\\
&=\sum_{i=0}^{\log_2(n)}2^i i
\end{align*}</script></p>
<p>即我们要求和式：<script type="math/tex">S_n=\sum_{k=0}^n 2^k k</script></p>
<p>的值。</p>
<p>对和式用扰动法，得：<script type="math/tex">\begin{align*}
S_n+(n+1)2^{n+1}&=\sum_{k=0}^n (k+1)2^{k+1}\\
S_n+(n+1)2^{n+1}&=2\sum_{k=0}^n k 2^k+2\sum_{k=0}^n 2^k\\
S_n+(n+1)2^{n+1}&=2S_n+2^{n+2}-2\\
-S_n&=2^{n+2}-2-(n+1)2^{n+1}\\
S_n&=2((n+1)2^n-2^{n+1}+1)\\
S_n&=2(2^n n-2^n+1)
\end{align*}</script></p>
<p>代入，得：<script type="math/tex">\begin{align*}
T(n)&=S_{\log_2(n)}\\
&=2(2^{\log_2(n)}\log_2(n)-2^{\log_2(n)}+1)\\
&=2(n\log_2(n)-n+1)\\
\end{align*}</script></p>
<p>则时间复杂度为：<script type="math/tex">O(T(n))=O(n \log n)</script></p>
<p>因为多项式乘法的常数为$3$，因此多项式求逆的常数为$2\times3=6$。</p>
<h2 id="3-多项式开根"><a href="#3-多项式开根" class="headerlink" title="3.多项式开根"></a>3.多项式开根</h2><p>前置：多项式求逆。</p>
<p>现在我们有一个次数界为$n$的多项式$A(x)$，要求$B(x)$满足$B(x)^2\equiv A(x)\pmod{x^n}$。</p>
<p>还是倍增。</p>
<ul>
<li>当$n=1$时，$B(x)$等于$A(x)$在模意义下的开根。</li>
<li>当$n&gt;1$时，已有$G(x)^2\equiv A(x)\pmod{x^\frac{n}{2}}$：</li>
</ul>
<p>因为：<script type="math/tex">G(x)^2\equiv A(x)\pmod{x^\frac{n}{2}}</script></p>
<p>移项，得：<script type="math/tex">G(x)^2-A(x)\equiv 0\pmod{x^\frac{n}{2}}</script></p>
<p>两边平方，同理可得：<script type="math/tex">G(x)^4-2 G(x)^2 A(x)+A(x)^2\equiv 0\pmod{x^n}</script></p>
<p>所以：<script type="math/tex">[G(x)^2+A(x)]^2-4 G(x)^2 A(x)\equiv 0\pmod{x^n}</script></p>
<p>即：<script type="math/tex">[G(x)^2+A(x)]^2\equiv 4 G(x)^2 A(x)\pmod{x^n}</script></p>
<p>除过去：<script type="math/tex">\frac{[G(x)^2+A(x)]^2}{4 G(x)^2}\equiv A(x)\pmod{x^n}</script></p>
<p>得到：<script type="math/tex">A(x)\equiv\left(\frac{G(x)^2+A(x)}{2 G(x)}\right)^2\equiv B(x)^2\pmod{x^n}</script></p>
<p>即：<script type="math/tex">B(x)\equiv\frac{G(x)^2+A(x)}{2 G(x)}\equiv\frac{A(x)}{2 G(x)}+\frac{G(x)}{2}\pmod{x^n}</script></p>
<p>这就可以了。</p>
<p>时间复杂度：$O(n\log n)$，常数为$2\times(6+3)=18$。</p>
<h2 id="4-多项式求导"><a href="#4-多项式求导" class="headerlink" title="4.多项式求导"></a>4.多项式求导</h2><p>根据导数的可加性和幂函数求导法则$\frac{\mathbb{d}(cx^k)}{\mathbb{d}x}=c k x^{k-1}$，有多项式的导数为：<script type="math/tex">\frac{\mathbb{d}(\sum\limits_{k=0}^{n-1}a_k x^k)}{\mathbb{d} x}=\sum_{k=0}^{n-1}\frac{\mathbb{d}(a_k x^k)}{\mathbb{d} x}=\sum_{k=1}^{n-1}k a_k x^{k-1}=\sum_{k=0}^{n-2}(k+1)a_{k+1}x^k</script></p>
<p>时间复杂度：$O(n)$，常数为$1$。</p>
<h2 id="5-多项式积分"><a href="#5-多项式积分" class="headerlink" title="5.多项式积分"></a>5.多项式积分</h2><p>根据积分的可加性和幂函数的不定积分$\displaystyle\int c x^k\mathbb{d}x=\frac{c}{k}x^{k+1}$，有多项式的不定积分为：<script type="math/tex">\int\sum_{k=0}^{n-1}a_k x^k \mathbb{d}x=\sum_{k=0}^{n-1}\int a_k x^k\mathbb{d}x=\sum_{k=0}^{n-1}\frac{a_k}{k+1}x^{k+1}=\sum_{k=1}^n\frac{a_{k-1}}{k}x^k</script></p>
<p>时间复杂度：$O(n)$，常数为$1$。</p>
<h2 id="6-多项式求ln"><a href="#6-多项式求ln" class="headerlink" title="6.多项式求ln"></a>6.多项式求ln</h2><p>前置：多项式求导&amp;积分&amp;求逆</p>
<p>现在已知多项式$A(x)$，要求$B(x)=\ln A(x)$。我们两边微分，得到：<script type="math/tex">B'(x)=\frac{\mathbb{d}(\ln A(x))}{\mathbb{d} A(x)}\frac{\mathbb{d} A(x)}{\mathbb{d} x}</script></p>
<script type="math/tex; mode=display">B'(x)=\frac{A'(x)}{A(x)}</script><p>再两边积分，就得到：<script type="math/tex">B(x)=\int\frac{A'(x)}{A(x)}\mathbb{d}x</script></p>
<p>因此，我们直接多项式求导+求逆+积分解决。</p>
<p>时间复杂度：$O(n\log n)$，常数为$6+3=9$。</p>
<h2 id="7-多项式求exp"><a href="#7-多项式求exp" class="headerlink" title="7.多项式求exp"></a>7.多项式求exp</h2><p>前置：多项式求ln</p>
<p>现在，我们已知多项式$A=A(x)$（这样写是因为在这里把$A$视为是与$x$无关的），求$F(x)=\exp(A)=e^{A}$。只要我们设$G(x)=\ln x-A$，就得到：<script type="math/tex">G(F(x))=\ln F(x)-A=0</script></p>
<p>我们考虑用<strong>牛顿迭代法</strong>来<strong>倍增</strong>解这个方程。</p>
<p>对于牛顿迭代法的初始解，即结果的常数项，我们并不知道具体值。但是如果不对的话，也只是缺少了一个常数罢了，那我们不妨设$F(x)=1$。</p>
<p>倍增：现在设我们已经求出了$F(x)$的前$n$项$F_0(x)$，即：<script type="math/tex">F_0(x)\equiv F(x)\pmod{x^n}</script></p>
<p>根据牛顿迭代法，我们求出下一个近似解为：<script type="math/tex">F(x)\equiv F_0(x)-\frac{G(F_0(x))}{G'(F_0(x))}\equiv F_0(x)-\frac{\ln F_0(x)-A}{F_0(x)^{-1}}\equiv F_0(x)(1-\ln F_0(x)+A(x))</script></p>
<p>如此，就可以倍增实现了。</p>
<p>时间复杂度：$O(n\log n)$，常数：$2\times(9+3)=24$。</p>
<h2 id="8-多项式求幂"><a href="#8-多项式求幂" class="headerlink" title="8.多项式求幂"></a>8.多项式求幂</h2><p>已知多项式$A(x)$和指数$k$，求$A(x)^k$。</p>
<p>在幂数很大的时候，如果使用快速幂的思想，时间复杂度为$O(n \log n\log k)$，常数为$6$。当$k$很大时速度很慢，我们必须进行优化。</p>
<p>我们发现：<script type="math/tex">A(x)^k=\left(e^{\ln A(x)}\right)^k=e^{k \ln A(x)}=\exp(k \ln A(x))</script></p>
<p>于是我们可以用多项式求ln+多项式求exp求出。</p>
<p>时间复杂度：$O(n\log n)$，常数：$9+24=33$。</p>
<h2 id="9-时间复杂度总结"><a href="#9-时间复杂度总结" class="headerlink" title="9.时间复杂度总结"></a>9.时间复杂度总结</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">内容</th>
<th style="text-align:center">时间复杂度</th>
<th style="text-align:center">常数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">多项式卷积</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$3$</td>
</tr>
<tr>
<td style="text-align:center">多项式求逆</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$6$</td>
</tr>
<tr>
<td style="text-align:center">多项式开根</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$18$</td>
</tr>
<tr>
<td style="text-align:center">多项式求导</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">多项式积分</td>
<td style="text-align:center">$O(n)$</td>
<td style="text-align:center">$1$</td>
</tr>
<tr>
<td style="text-align:center">多项式求ln</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$9$</td>
</tr>
<tr>
<td style="text-align:center">多项式求exp</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$24$</td>
</tr>
<tr>
<td style="text-align:center">多项式求幂</td>
<td style="text-align:center">$O(n\log n)$</td>
<td style="text-align:center">$33$</td>
</tr>
</tbody>
</table>
</div>
<h1 id="7、代码实现"><a href="#7、代码实现" class="headerlink" title="7、代码实现"></a>7、代码实现</h1><h2 id="1-二进制反转"><a href="#1-二进制反转" class="headerlink" title="1.二进制反转"></a>1.二进制反转</h2><p>可以用一种类似dp的思想计算。</p>
<p>边界：$0$的二进制翻转为$0$</p>
<p>递归式：对于$a$，已经算出了$rev_{\lfloor\frac{a}{2}\rfloor}$，$a$就是除去最后一位的二进制翻转($rev_{\lfloor\frac{a}{2}\rfloor}$)向后移动一位再补上第一位。即：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rev[a]=(rev[a&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((a&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>))</span><br></pre></td></tr></table></figure></p>
<p>$l$为要翻转的位数。</p>
<h2 id="2-复数类"><a href="#2-复数类" class="headerlink" title="2.复数类"></a>2.复数类</h2><p>套公式即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> re,im;</span><br><span class="line">	<span class="keyword">complex</span>(<span class="keyword">double</span> re=<span class="number">0</span>,<span class="keyword">double</span> im=<span class="number">0</span>):re(re),im(im)&#123;&#125;</span><br><span class="line">	<span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">complex</span> &amp;b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(re+b.re,im+b.im);&#125;</span><br><span class="line">	<span class="keyword">complex</span> <span class="keyword">operator</span>-(<span class="keyword">complex</span> &amp;b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(re-b.re,im-b.im);&#125;</span><br><span class="line">	<span class="keyword">complex</span> <span class="keyword">operator</span>*(<span class="keyword">complex</span> &amp;b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(re*b.re-im*b.im,re*b.im+im*b.re);&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-FFT"><a href="#3-FFT" class="headerlink" title="3.FFT"></a>3.FFT</h2><ul>
<li>1：根据二进制翻转交换$a_r$和$a_{rev(r)}$</li>
<li>2：枚举归并步长$i\in[1,n)$，$i$为二的幂；<ul>
<li>2.1： 根据欧拉公式求出$\omega_{2 i}^1=\cos\frac{\pi}{i}+i\sin\frac{\pi}{i}$</li>
<li>2.2：枚举归并位置$j$，归并$[j,j+i)$和$[j+i,j+2 i)$，步长为$2 i$<ul>
<li>2.2.1：枚举$x$的幂数$k\in[0,i)$进行蝴蝶操作计算$y$，根据单位根计算$\omega_i^k$<ul>
<li>2.2.1.1：$y_{j+k}=y_{j+k}+\omega_{2 i}^k y_{j+k+i}$</li>
<li>2.2.1.2：$y_{j+k+i}=y_{j+k}-\omega_{2 i}^k y_{j+k+i}$</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>注意：由于在C++中值会被更改，因此需要引入临时变量。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">complex</span> c[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])swap(c[i],c[r[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">complex</span> <span class="title">omn</span><span class="params">(<span class="built_in">cos</span>(pi/i),<span class="built_in">sin</span>(pi/i))</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">			<span class="function"><span class="keyword">complex</span> <span class="title">om</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++,om=om*omn)&#123;</span><br><span class="line">				<span class="keyword">complex</span> x=c[j+k],y=om*c[j+k+i];</span><br><span class="line">				c[j+k]=x+y;</span><br><span class="line">				c[j+k+i]=x-y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="4-IFFT"><a href="#4-IFFT" class="headerlink" title="4.IFFT"></a>4.IFFT</h2><p>由于公式中只差一个负号而已，因此引入一个参数$type$，在欧拉公式的地方乘上去，再除以$n$就可以了。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">complex</span> c[],<span class="keyword">int</span> tp=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])swap(c[i],c[r[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">complex</span> <span class="title">omn</span><span class="params">(<span class="built_in">cos</span>(pi/i),tp*<span class="built_in">sin</span>(pi/i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="function"><span class="keyword">complex</span> <span class="title">om</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++,om=om*omn)&#123;</span><br><span class="line">                <span class="keyword">complex</span> x=c[j+k],y=om*c[j+k+i];</span><br><span class="line">                c[j+k]=x+y;</span><br><span class="line">                c[j+k+i]=x-y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IFFT</span><span class="params">(<span class="keyword">complex</span> c[])</span></span>&#123;</span><br><span class="line">	FFT(c,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)a[i].re/=n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="5-多项式乘法"><a href="#5-多项式乘法" class="headerlink" title="5.多项式乘法"></a>5.多项式乘法</h2><p>模板：<a href="https://www.luogu.org/problemnew/show/P3803" target="_blank" rel="noopener">洛谷3083</a></p>
<p>注意：</p>
<p>1、由于FFT要求$n$为$2$的幂且结果的次数界较大，所以要把两个因式的系数补到$l$位，$l$满足$l=2^t$且$l/2$大于等于因式的次数界。</p>
<p>2、$FFT$虽然在数学上精准，但在C++中误差巨大，因此虚部不会为$0$，忽略即可。实部也不为正数，可以加上$0.1$再向下取整。</p>
<p>代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">    <span class="keyword">double</span> re,im;</span><br><span class="line">    <span class="keyword">complex</span>(<span class="keyword">double</span> re=<span class="number">0</span>,<span class="keyword">double</span> im=<span class="number">0</span>):re(re),im(im)&#123;&#125;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">complex</span> &amp;b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(re+b.re,im+b.im);&#125;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span>-(<span class="keyword">complex</span> &amp;b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(re-b.re,im-b.im);&#125;</span><br><span class="line">    <span class="keyword">complex</span> <span class="keyword">operator</span>*(<span class="keyword">complex</span> &amp;b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(re*b.re-im*b.im,re*b.im+im*b.re);&#125;</span><br><span class="line">&#125;a[<span class="number">2097153</span>],b[<span class="number">2097153</span>];</span><br><span class="line"><span class="keyword">int</span> n,m,l,r[<span class="number">2097153</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">complex</span> c[],<span class="keyword">int</span> tp=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])swap(c[i],c[r[i]]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">complex</span> <span class="title">omn</span><span class="params">(<span class="built_in">cos</span>(pi/i),tp*<span class="built_in">sin</span>(pi/i))</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">            <span class="function"><span class="keyword">complex</span> <span class="title">om</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++,om=om*omn)&#123;</span><br><span class="line">                <span class="keyword">complex</span> x=c[j+k],y=om*c[j+k+i];</span><br><span class="line">                c[j+k]=x+y;</span><br><span class="line">                c[j+k+i]=x-y;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IFFT</span><span class="params">(<span class="keyword">complex</span> c[])</span></span>&#123;</span><br><span class="line">	FFT(c,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)a[i].re/=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;a[i].re);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)<span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;b[i].re);</span><br><span class="line">    m+=n;</span><br><span class="line">    <span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;=m;n&lt;&lt;=<span class="number">1</span>)l++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">    FFT(a);</span><br><span class="line">    FFT(b);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)a[i]=a[i]*b[i];</span><br><span class="line">    IFFT(a);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,<span class="keyword">int</span>(a[i].re+<span class="number">0.5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="6-I-FFT-I-NTT"><a href="#6-I-FFT-I-NTT" class="headerlink" title="6.(I)FFT+(I)NTT"></a>6.(I)FFT+(I)NTT</h2><p>给出一个$n$次多项式和一个$m$次多项式的系数表达($1\le n,m\le 4000000$)，求乘积。$type=0$时，直接计算；$type=1$时，结果取模$998244353$(原根为$3$)。</p>
<p>注：为了方便阅读，代码效率不高。若要提速，可以把单位根打表。而且，由于$g^\frac{p-1}{n}$中$\frac{p-1}{n}$必须为整数，故仅在第一个比$n+m$大的$2$的整数次幂是$p-1$的约数时才可行，此处$998244353-1=998244352=119\times2^{23}$，$2^{23}=8388608&gt;n+m$。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> p=<span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">	<span class="keyword">double</span> re,im;</span><br><span class="line">	<span class="keyword">complex</span>(<span class="keyword">double</span> re=<span class="number">0</span>,<span class="keyword">double</span> im=<span class="number">0</span>):re(re),im(im)&#123;&#125;</span><br><span class="line">	<span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">complex</span> b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(re+b.re,im+b.im);&#125;</span><br><span class="line">	<span class="keyword">complex</span> <span class="keyword">operator</span>-(<span class="keyword">complex</span> b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(re-b.re,im-b.im);&#125;</span><br><span class="line">	<span class="keyword">complex</span> <span class="keyword">operator</span>*(<span class="keyword">complex</span> b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(re*b.re-im*b.im,re*b.im+im*b.re);&#125;</span><br><span class="line">&#125;af[<span class="number">131073</span>],bf[<span class="number">131073</span>];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">modp</span>&#123;</span></span><br><span class="line">	<span class="keyword">int</span> a;</span><br><span class="line">	modp(<span class="keyword">int</span> a=<span class="number">0</span>):a(a)&#123;&#125;</span><br><span class="line">	modp <span class="keyword">operator</span>+(modp b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> (a+b.a)%p;&#125;</span><br><span class="line">	modp <span class="keyword">operator</span>-(modp b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> (a-b.a+p)%p;&#125;</span><br><span class="line">	modp <span class="keyword">operator</span>*(modp b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> ll(a)*b.a%p;&#125;</span><br><span class="line">	modp <span class="keyword">operator</span>/(modp b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> (b^(p<span class="number">-2</span>))*a;&#125;</span><br><span class="line">	modp <span class="keyword">operator</span>^(<span class="keyword">int</span> b)<span class="keyword">const</span>&#123;</span><br><span class="line">		modp ans=<span class="number">1</span>,bs=a;</span><br><span class="line">		<span class="keyword">while</span>(b)&#123;</span><br><span class="line">			<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=ans*bs;</span><br><span class="line">			bs=bs*bs;</span><br><span class="line">			b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> ans;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;an[<span class="number">131073</span>],bn[<span class="number">131073</span>];</span><br><span class="line"><span class="keyword">const</span> modp g=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> n,m,l,r[<span class="number">131073</span>],type;</span><br><span class="line">modp gn[<span class="number">18</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	m+=n;</span><br><span class="line">	<span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;=m;n&lt;&lt;=<span class="number">1</span>)l++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">17</span>;i++)gn[i]=g^((p<span class="number">-1</span>)/(<span class="number">1</span>&lt;&lt;i));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">complex</span> c[],<span class="keyword">int</span> tp=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])swap(c[i],c[r[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">complex</span> <span class="title">omn</span><span class="params">(<span class="built_in">cos</span>(pi/i),tp*<span class="built_in">sin</span>(pi/i))</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">			<span class="function"><span class="keyword">complex</span> <span class="title">om</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++,om=om*omn)&#123;</span><br><span class="line">				<span class="keyword">complex</span> x=c[j+k],y=om*c[j+k+i];</span><br><span class="line">				c[j+k]=x+y;</span><br><span class="line">				c[j+k+i]=x-y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IFFT</span><span class="params">(<span class="keyword">complex</span> c[])</span></span>&#123;</span><br><span class="line">	FFT(c,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)c[i].re/=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(modp c[],<span class="keyword">int</span> tp=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])swap(c[i],c[r[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,id=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>,id++)&#123;</span><br><span class="line">		modp ggn=gn[id]^(tp==<span class="number">1</span>?<span class="number">1</span>:p<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">			modp gg=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++,gg=gg*ggn)&#123;</span><br><span class="line">				modp x=c[j+k],y=gg*c[j+k+i];</span><br><span class="line">				c[j+k]=x+y;</span><br><span class="line">				c[j+k+i]=x-y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INTT</span><span class="params">(modp c[])</span></span>&#123;</span><br><span class="line">	NTT(c,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)c[i]=c[i]/n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;type);</span><br><span class="line">	<span class="keyword">if</span>(type==<span class="number">0</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;af[i].re);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)<span class="built_in">scanf</span>(<span class="string">"%lf"</span>,&amp;bf[i].re);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;an[i].a);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;bn[i].a);</span><br><span class="line">	&#125;</span><br><span class="line">	init();</span><br><span class="line">	<span class="keyword">if</span>(type==<span class="number">0</span>)&#123;</span><br><span class="line">		FFT(af);</span><br><span class="line">		FFT(bf);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)af[i]=af[i]*bf[i];</span><br><span class="line">		IFFT(af);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,<span class="keyword">int</span>(af[i].re+<span class="number">0.5</span>));</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		NTT(an);</span><br><span class="line">		NTT(bn);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)an[i]=an[i]*bn[i];</span><br><span class="line">		INTT(an);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)<span class="built_in">printf</span>(<span class="string">"%d "</span>,an[i].a);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>常数只有上面那个的三分之一的NTT（正式考试请务必采用这种写法）：</p>
<p>PS:有一道题上面那个3700ms,这个1000ms<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">pow</span><span class="params">(ll a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">	ll ans=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(b)&#123;</span><br><span class="line">		<span class="keyword">if</span>(b&amp;<span class="number">1</span>)ans=ans*a%p;</span><br><span class="line">		a=a*a%p;</span><br><span class="line">		b&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">add</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a+b&gt;p?a+b-p:a+b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">cut</span><span class="params">(ll a,ll b)</span></span>&#123;<span class="keyword">return</span> a-b&lt;<span class="number">0</span>?a-b+p:a-b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;=s;n&lt;&lt;=<span class="number">1</span>);</span><br><span class="line">	nn=n;</span><br><span class="line">	gn[<span class="number">0</span>][<span class="number">0</span>]=gn[<span class="number">1</span>][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	gn[<span class="number">0</span>][<span class="number">1</span>]=<span class="built_in">pow</span>(g,(p<span class="number">-1</span>)/(n&lt;&lt;<span class="number">1</span>));</span><br><span class="line">	gn[<span class="number">1</span>][<span class="number">1</span>]=<span class="built_in">pow</span>(gn[<span class="number">0</span>][<span class="number">1</span>],p<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;(n&lt;&lt;<span class="number">1</span>);i++)&#123;gn[<span class="number">0</span>][i]=gn[<span class="number">0</span>][i<span class="number">-1</span>]*gn[<span class="number">0</span>][<span class="number">1</span>]%p;gn[<span class="number">1</span>][i]=gn[<span class="number">1</span>][i<span class="number">-1</span>]*gn[<span class="number">1</span>][<span class="number">1</span>]%p;&#125;</span><br><span class="line">	inv[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=(n&lt;&lt;<span class="number">1</span>);i++)inv[i]=inv[p%i]*(p-p/i)%p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(ll c[],<span class="keyword">int</span> n,<span class="keyword">int</span> tp=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span>(i&lt;r[i])swap(c[i],c[r[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++)&#123;</span><br><span class="line">				ll x=c[j+k],y=gn[tp!=<span class="number">1</span>][nn/i*k]*c[j+k+i]%p;</span><br><span class="line">				c[j+k]=add(x,y);</span><br><span class="line">				c[j+k+i]=cut(x,y);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INTT</span><span class="params">(ll c[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	NTT(c,n,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)c[i]=c[i]*inv[n]%p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="7-任意模数FFT"><a href="#7-任意模数FFT" class="headerlink" title="7.任意模数FFT"></a>7.任意模数FFT</h2><p>给定$n,m,P$，再给定次数界为$n$的第一个多项式和次数界为$m$的第二个多项式，求两个多项式的卷积模$P$。</p>
<p>注意：拆系数FFT精度损失极大，需要使用long double保证正确性。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">int</span> x,n,m,l,r[<span class="number">262145</span>],pm,p;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">long</span> <span class="keyword">double</span> pi=<span class="built_in">acos</span>(<span class="number">-1</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">complex</span>&#123;</span></span><br><span class="line">	<span class="keyword">long</span> <span class="keyword">double</span> re,im;</span><br><span class="line">	<span class="keyword">complex</span>(<span class="keyword">long</span> <span class="keyword">double</span> re=<span class="number">0</span>,<span class="keyword">long</span> <span class="keyword">double</span> im=<span class="number">0</span>):re(re),im(im)&#123;&#125;</span><br><span class="line">	<span class="keyword">complex</span> <span class="keyword">operator</span>+(<span class="keyword">const</span> <span class="keyword">complex</span> &amp;b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(re+b.re,im+b.im);&#125;</span><br><span class="line">	<span class="keyword">complex</span> <span class="keyword">operator</span>-(<span class="keyword">const</span> <span class="keyword">complex</span> &amp;b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(re-b.re,im-b.im);&#125;</span><br><span class="line">	<span class="keyword">complex</span> <span class="keyword">operator</span>*(<span class="keyword">const</span> <span class="keyword">complex</span> &amp;b)<span class="keyword">const</span>&#123;<span class="keyword">return</span> <span class="keyword">complex</span>(re*b.re-im*b.im,re*b.im+im*b.re);&#125;</span><br><span class="line">&#125;k1[<span class="number">262145</span>],r1[<span class="number">262145</span>],k2[<span class="number">262145</span>],r2[<span class="number">262145</span>],c1[<span class="number">262145</span>],c2[<span class="number">262145</span>],c3[<span class="number">262145</span>];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FFT</span><span class="params">(<span class="keyword">complex</span> c[],<span class="keyword">int</span> tp=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="keyword">if</span>(i&lt;r[i])swap(c[i],c[r[i]]);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="function"><span class="keyword">complex</span> <span class="title">omn</span><span class="params">(<span class="built_in">cos</span>(pi/i),tp*<span class="built_in">sin</span>(pi/i))</span></span>;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">			<span class="function"><span class="keyword">complex</span> <span class="title">om</span><span class="params">(<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++,om=om*omn)&#123;</span><br><span class="line">				<span class="keyword">complex</span> x=c[j+k],y=om*c[j+k+i];</span><br><span class="line">				c[j+k]=x+y;</span><br><span class="line">				c[j+k+i]=x-y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IFFT</span><span class="params">(<span class="keyword">complex</span> c[])</span></span>&#123;</span><br><span class="line">	FFT(c,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)c[i].re/=n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">	m+=n;</span><br><span class="line">	<span class="keyword">for</span>(n=<span class="number">1</span>;n&lt;=m;n&lt;&lt;=<span class="number">1</span>)l++;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)&lt;&lt;(l<span class="number">-1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>,&amp;n,&amp;m,&amp;p);</span><br><span class="line">	pm=<span class="built_in">sqrt</span>(p);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">		k1[i]=x/pm;</span><br><span class="line">		r1[i]=x%pm;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		<span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">		k2[i]=x/pm;</span><br><span class="line">		r2[i]=x%pm;</span><br><span class="line">	&#125;</span><br><span class="line">	init();</span><br><span class="line">	FFT(k1);</span><br><span class="line">	FFT(r1);</span><br><span class="line">	FFT(k2);</span><br><span class="line">	FFT(r2);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		c1[i]=k1[i]*k2[i];</span><br><span class="line">		c2[i]=k1[i]*r2[i]+r1[i]*k2[i];</span><br><span class="line">		c3[i]=r1[i]*r2[i];</span><br><span class="line">	&#125;</span><br><span class="line">	IFFT(c1);</span><br><span class="line">	IFFT(c2);</span><br><span class="line">	IFFT(c3);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=m;i++)&#123;</span><br><span class="line">		ll s1=ll(c1[i].re+<span class="number">0.5</span>)%p*pm%p*pm%p,s2=ll(c2[i].re+<span class="number">0.5</span>)%p*pm%p,s3=ll(c3[i].re+<span class="number">0.5</span>)%p;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"%lld "</span>,((s1+s2)%p+s3)%p);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-多项式的运算"><a href="#7-多项式的运算" class="headerlink" title="7.多项式的运算"></a>7.多项式的运算</h2><p>依赖关系：<br><img src="https://img-blog.csdn.net/20180723211153506?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0VaX1RKWQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt=""><br>直接按照公式打就好了。</p>
<p>我们先修改NTT：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NTT</span><span class="params">(modp c[],<span class="keyword">int</span> n,<span class="keyword">int</span> tp=<span class="number">1</span>)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		r[i]=(r[i&gt;&gt;<span class="number">1</span>]&gt;&gt;<span class="number">1</span>)|((i&amp;<span class="number">1</span>)*(n&gt;&gt;<span class="number">1</span>));</span><br><span class="line">		<span class="keyword">if</span>(i&lt;r[i])swap(c[i],c[r[i]]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>,id=<span class="number">1</span>;i&lt;n;i&lt;&lt;=<span class="number">1</span>,id++)&#123;</span><br><span class="line">		modp ggn=gn[id]^(tp==<span class="number">1</span>?<span class="number">1</span>:p<span class="number">-2</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j+=(i&lt;&lt;<span class="number">1</span>))&#123;</span><br><span class="line">			modp gg=<span class="number">1</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;i;k++,gg=gg*ggn)&#123;</span><br><span class="line">				modp x=c[j+k],y=gg*c[j+k+i];</span><br><span class="line">				c[j+k]=x+y;</span><br><span class="line">				c[j+k+i]=x-y;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">INTT</span><span class="params">(modp c[],<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">	NTT(c,n,<span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)c[i]=c[i]/n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>求逆：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inverse</span><span class="params">(modp c[],<span class="keyword">int</span> n=n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> modp t[<span class="number">262145</span>],tma[<span class="number">262145</span>];</span><br><span class="line">	t[<span class="number">0</span>]=c[<span class="number">0</span>]^(p<span class="number">-2</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=n;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(k&lt;&lt;<span class="number">1</span>);i++)tma[i]=(i&lt;k?c[i]:<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=(k&gt;&gt;<span class="number">1</span>);i&lt;(k&lt;&lt;<span class="number">1</span>);i++)t[i]=<span class="number">0</span>;</span><br><span class="line">		NTT(tma,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		NTT(t,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(k&lt;&lt;<span class="number">1</span>);i++)t[i]=t[i]*<span class="number">2</span>-t[i]*t[i]*tma[i];</span><br><span class="line">		INTT(t,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(c,t,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>开根($c[0]=1$)：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sqrt</span><span class="params">(modp c[],<span class="keyword">int</span> n=n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> modp t[<span class="number">262145</span>],tma[<span class="number">262145</span>],tmb[<span class="number">262145</span>];</span><br><span class="line">	t[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=n;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)tma[i]=t[i]*<span class="number">2</span>;</span><br><span class="line">		inverse(tma,k);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(k&lt;&lt;<span class="number">1</span>);i++)tmb[i]=(i&lt;k?c[i]:<span class="number">0</span>);</span><br><span class="line">		NTT(tma,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		NTT(tmb,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(k&lt;&lt;<span class="number">1</span>);i++)&#123;</span><br><span class="line">			modp tmp=tma[i];</span><br><span class="line">			tma[i]=t[i];</span><br><span class="line">			t[i]=tmp*tmb[i];</span><br><span class="line">		&#125;</span><br><span class="line">		INTT(t,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(k&lt;&lt;<span class="number">1</span>);i++)t[i]=(i&lt;k?t[i]+tma[i]/<span class="number">2</span>:<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(c,t,<span class="keyword">sizeof</span>(<span class="keyword">int</span>)*n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>求导：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">derivative</span><span class="params">(modp c[],<span class="keyword">int</span> n=n)</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)c[i]=c[i+<span class="number">1</span>]*(i+<span class="number">1</span>);&#125;</span><br></pre></td></tr></table></figure></p>
<p>积分：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">integrate</span><span class="params">(modp c[],<span class="keyword">int</span> n=n)</span></span>&#123;<span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-1</span>;i&gt;=<span class="number">1</span>;i--)c[i]=c[i<span class="number">-1</span>]*inv[i];c[<span class="number">0</span>]=<span class="number">0</span>;&#125;</span><br></pre></td></tr></table></figure></p>
<p>求ln：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ln</span><span class="params">(modp c[],<span class="keyword">int</span> n=n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> modp t[<span class="number">262145</span>];</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&lt;&lt;<span class="number">1</span>);i++)t[i]=(i&lt;n?c[i]:<span class="number">0</span>);</span><br><span class="line">	derivative(t,n);</span><br><span class="line">	inverse(c,n);</span><br><span class="line">	NTT(t,n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	NTT(c,n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(n&lt;&lt;<span class="number">1</span>);i++)c[i]=c[i]*t[i];</span><br><span class="line">	INTT(c,n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=n;i&lt;(n&lt;&lt;<span class="number">1</span>);i++)c[i]=<span class="number">0</span>;</span><br><span class="line">	integrate(c,n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>求exp：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exp</span><span class="params">(modp c[])</span></span>&#123;</span><br><span class="line">	<span class="keyword">static</span> modp t[<span class="number">262145</span>],ta[<span class="number">262145</span>];</span><br><span class="line">	t[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">2</span>;k&lt;=n;k&lt;&lt;=<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(k&lt;&lt;<span class="number">1</span>);i++)ta[i]=t[i];</span><br><span class="line">		ln(ta,k);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)ta[i]=c[i]-ta[i];</span><br><span class="line">		ta[<span class="number">0</span>].a++;</span><br><span class="line">		NTT(t,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		NTT(ta,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;(k&lt;&lt;<span class="number">1</span>);i++)t[i]=t[i]*ta[i];</span><br><span class="line">		INTT(t,k&lt;&lt;<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i=k;i&lt;(k&lt;&lt;<span class="number">1</span>);i++)t[i]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">memcpy</span>(c,t,<span class="keyword">sizeof</span>(modp)*n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>求幂：<br>我们在多项式求exp中假定了$c[0]=1$，那么如果常数项不是$1$的话我们就把常数项变为$1$在运算后再用快速幂变回来即可。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pow</span><span class="params">(modp c[],<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">	ln(c);</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)c[i]=c[i]*k;</span><br><span class="line">	<span class="built_in">exp</span>(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="8、拉格朗日反演"><a href="#8、拉格朗日反演" class="headerlink" title="8、拉格朗日反演"></a>8、拉格朗日反演</h1><h2 id="1-形式幂级数"><a href="#1-形式幂级数" class="headerlink" title="1.形式幂级数"></a>1.形式幂级数</h2><p>对于任意一个域$F$我们定义在其上的<strong>形式幂级数</strong>为：<script type="math/tex">f(x)=\sum_{k=0}^\infty a_k x^k,a_k\in F</script><br>记所有的形式幂级数为$F[[x]]$。</p>
<h2 id="2-反演公式"><a href="#2-反演公式" class="headerlink" title="2.反演公式"></a>2.反演公式</h2><blockquote>
<p>拉格朗日反演是求关于函数方程的幂级数展开系数非常重要的工具，可以用于组合计数函数的系数提取。</p>
</blockquote>
<p><strong>公式内容</strong>：</p>
<blockquote>
<p>这里$[x^n]f(x)$指取$f(x)$中$x^n$的系数。</p>
</blockquote>
<p>若$f(x),g(x)\in F[[x]]$且$f(g(x))=x$，则称$f(x)$为$g(x)$的<strong>复合逆</strong>。满足：<script type="math/tex">[x^n]g(x)=\frac{1}{n}[x^{-1}]\frac{1}{f(x)^n}\tag{1}</script><br>特别的，如果$f(x)=\displaystyle\frac{x}{\phi(x)}$，那么有：<script type="math/tex">[x^n]g(x)=\frac{1}{n}[x^{n-1}]\phi(x)^n\tag{2}</script></p>
<p><strong>公式的推导</strong>：<br>由式$f(x)=\displaystyle\frac{x}{\phi(x)}$，得$\phi(x)=\displaystyle\frac{x}{f(x)}$，代入$(2)$式可得：<script type="math/tex">[x^n]g(x)=\frac{1}{n}[x^{n-1}]\left(\frac{x}{f(x)}\right)^n</script></p>
<p><strong>公式的推广</strong>：</p>
<script type="math/tex; mode=display">[x^n]h(g(x))=\frac{1}{n}[x^{n-1}]h'(x)\left(\frac{x}{f(x)}\right)^n</script>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://eztjy.ml/2019/01/19/拉格朗日反演-FFT-NTT-多项式大全-详解/" data-id="cjr3h0qya0001cwu4bkzrsf48" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/01/18/hello-world/" class="article-date">
  <time datetime="2019-01-18T07:58:04.144Z" itemprop="datePublished">2019-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/01/18/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://eztjy.ml/2019/01/18/hello-world/" data-id="cjr3h0qxa0000cwu4hl51or06" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/01/">January 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/01/19/拉格朗日反演-FFT-NTT-多项式大全-详解/">[拉格朗日反演][FFT][NTT][多项式大全]详解</a>
          </li>
        
          <li>
            <a href="/2019/01/18/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div><!-- hexo-inject:begin --><!-- Begin: Injected MathJax -->
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({"tex2jax":{"inlineMath":[["$","$"],["\\(","\\)"]],"skipTags":["script","noscript","style","textarea","pre","code"],"processEscapes":true},"TeX":{"equationNumbers":{"autoNumber":"AMS"}}});
</script>

<script type="text/x-mathjax-config">
  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
      all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script>

<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js">
</script>
<!-- End: Injected MathJax -->
<!-- hexo-inject:end -->
</body>
</html>